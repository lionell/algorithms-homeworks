\documentclass[
  11pt,
  a4paper
]{extarticle}

\usepackage[
  a4paper,
  left = 10mm,
  right = 10mm,
  top = 5mm,
  bottom = 5mm,
  bindingoffset = 0cm,
  columnsep = 1cm
]{geometry}

\usepackage{lipsum}
\usepackage{amsmath,amssymb,amsthm}
\usepackage[utf8]{inputenc}
\usepackage[ukrainian]{babel}
\usepackage{indentfirst}
\usepackage{cmap}
\usepackage{ifthen}
\usepackage{tikz}
\usepackage{wrapfig}
\usepackage{enumerate}
\usepackage{dirtytalk}

\newtheorem{lemma}{Лема}

\theoremstyle{definition}
\newtheorem{definition}{Означення}
\newtheorem{denotation}{Позначення}

\theoremstyle{remark}
\newtheorem*{remark}{Зауваження}

\title{Домашаня робота №3 з курсу \\ <<Алгоритми та структури даних>>}
\author{Сакевич Руслан}

\begin{document}
\maketitle

\section{Поняття та позначення}
  
  Будемо вважати, що строка $s$ з умови задає певний шаблон. Зрозуміло, що будь-яка підсторка $s[l, r]$ строки $s$ також задає певний шаблон.
  \begin{denotation}
    ПДП - правильна дужкова послідовність.
  \end{denotation}
  \begin{definition}
    Строка $s$ задає ПДП $T$, якщо існує певна підстановка дужок, замість знаків питання, яка переводить $s$ в $T$.
  \end{definition}
  \begin{definition}
    ПДП називається \textbf{простою}, якщо вона не містить правильну дужкову \textbf{підпослідовність}.
  \end{definition}
  \begin{denotation}
    $f(l, r)$ -- число ПДП, що підпадають під шаблон $s[l, r]$.
  \end{denotation}
  \begin{denotation}
    $g(l, r)$ -- число простих ПДП, що підпадають під шаблон $s[l, r]$.
  \end{denotation}
\section{Алгоритм}
  \subsection{Про розбиття ПДП}
    \begin{lemma}
      Будь-яку ПДП T можна розбити на просту ПДП L та ПДП R меншого розміру. Причому T = L + R.
    \end{lemma}
    \begin{proof}
      Нехай $T$ -- ПДП, тоді будемо виконувати наступну ітерацію для чергової дужки з $T$:
      \begin{enumerate}
      \item{Якщо дужка відкриваюча, то додаємо її до стеку $S$.}
      \item{Якщо дужка закриваюча, то вилучаємо з стеку відповідну їй відкриваючу дужку. Це завжди можна зробити, оскільки $T$ -- ПДП.}
      \end{enumerate}
      Зрозуміло, що алгоритм \textbf{скінчений}. Розглянемо першу ітерацію, на якій стек $S$ -- порожній. На цій ітерації ми вже опрацювали певну підпослідовність дужок $L$. Тоді $L$ -- також ПДП. Більше того $L$ -- проста ПДП. Неважко бачити, що $T\backslash L = R$, також ПДП, та оскільки $L$ -- містить не менше однієї дужки, то довжина $R$ \textbf{менша} довжини $T$. Особливий випадок виникає тоді, коли $T$ -- проста ПДП, тоді $T = L$, а $R$ -- порожня, але цей випадок задовольняє умову леми. Отже ми навели алгоритм розбиття, що завершує доведення.
    \end{proof}
    \begin{remark}
      Легко трансформувати описаний алгоритм побудови розбиття, так щоб він розбивав ПДП $T$ на ПДП $L$ та просту ПДП $R$, так щоб $T = L + R$.
    \end{remark}
  \subsection{Підрахунок $f(l, r)$}
    Спочатку покажемо як рахувати $f(l, r)$. За лемою 1, будь-яку ПДП можна розбити на просту ПДП та ПДП меншого розміру. 
    В часності будь-яку ПДП породжену шаблоном $s[l, r]$ можна розбити на просту ПДП та ПДП меншого розміру. Нехай $h(l, m, r)$ -- число ПДП породжених шаблоном $s[l, r]$, таких, що $s[l, m]$ -- проста ПДП, а $s[m + 1, r]$ -- ПДП. 
    За правилом добутку $h(l, m, r) = g(l, m) \cdot f(m + 1, r)$. В цьому місці видно, що функцію $f(l, r)$ слід доозначити нулем у випадку $l > r$.
    \newpage
    \begin{lemma}
      $f(l, r) = \sum_{m = l}^{r}{h(l, m, r)}$
    \end{lemma}
    \begin{proof}
      Для доведення леми достатньо показати:
      \begin{enumerate}
        \item{Будь-яка ПДП породжена $s[l, r]$ буде врахована.}
        \item{Тільки ПДП породжені $s[l, r]$ будуть враховані, причому тільки один раз.}
      \end{enumerate}
      Для доведення першого пункту достатньо застосувати алгоритм наведений в лемі 1.
      Також очевидно, що не може бути врахована ПДП, що не підпадає під шаблон $s[l, r]$.
      Покажемо, що жодної ПДП породженої шаблоном $s[l, r]$ ми не врахуємо двічі. Припустимо, що це не так, і існує ПДП $T$ що підпадає під шаблон $s[l, r]$, і має два розбиття $L_{1} + R_{1}$ та $L_{2} + R_{2}$. Виберемо найкоротшу просту ПДП з $L_{1}$ та $L_{2}$. Не порушуючи загальності будемо вважати, що це $L_{1}$. Тоді $L_{2}$ містить в собі $L_{1}$. Але оскільки $L_{1}$ також ПДП, то $L_{2}$ - не може бути ПДП(за визначенням). Отримане протиріччя завершує доведення.
    \end{proof}
    \subsection{Підрахунок $g(l, r)$}
      \begin{lemma}
        Будь-яка проста ПДП має вигляд
        \begin{itemize}
          \item{``('' $+$ ПДП $+$ ``)''}
          \item{``['' $+$ ПДП $+$ ``]''}
          \item{``\{'' $+$ ПДП $+$ ``\}''}
        \end{itemize}
      \end{lemma}
      \begin{proof}
        Дійсно, якщо припустити, що існує проста ПДП що підпадає під варіанти  умови, то алгоритм розбиття описаний в лемі 1 завершиться раніше, ніж розгляне останню дужку. Що суперечить визначенню простої ПДП.
      \end{proof}
      Тепер зрозуміло, як рахувати $g(l, r)$. Відкинувши зовнішні дужки перейдемо до шаблону $s[l + 1, r - 1]$. З леми 3 слідує, що
      \begin{align*}
        &g(l, r) = \lambda \cdot f(l + 1, r - 1) \text{, де} \\
        &\lambda = 
        \begin{cases}
          1, & \text{якщо дужки виду ``()'', ``[]'', ``\{\}'', ``?)'', ``?]'', ``?\}'', ``(?'', ``[?'', ``\{?''} \\
          3, & \text{якщо дужки виду ``??''} \\
          0, & \text{інакше} 
        \end{cases}
      \end{align*}
    \subsection{Зауваження}
      Слід зазначити, що при підрахунку $f(l, r)$ або $g(l, r)$ ми завжди зводимо задачу до задач, з \textbf{меншими границями}. Тому достатньо вказати початкові умови, і можна буде обрахувати значення функцій, для будь-яких $1 \leq l \leq r \leq n$. Неважко бачити, що відповідь на задачу $f(1, n)$
  \section{Складність алгоритму}
  Надалі йдеться лише про реалізації побудовані, на \textbf{мемоїзації}, або на \textbf{динамічному програмуванні}. Оскільки якщо обраховувати раніше знайдені величини повторно, то складність алгоритму одразу стає \textbf{\Largeекспоненціальною}!
  \subsection{Часова оцінка}
    Точну оцінку для алгоритму обрахувати досить важко. Покажемо, що верхня часова оцінка складає $O(N^{3})$. 
    Дійсно для обрахунку $f(1, n)$ може знадобитися обрахувати $f(i, j)$, для будь-яких $1 \leq i \leq j < n$. 
    Причому для обрахунку $f(i, j)$ виконується не більше $j - i$ рекурсивних викликів. Маємо: 
    \begin{equation*}
      \sum_{1 \leq i \leq j < n}{j - i} \leq n^{3}
    \end{equation*}
  \subsection{Оцінка використаної пам'яті}
    Ця величина дуже сильно залежить від реалізації алгоритму. Найменша оцінка, яку можна досягти: $O(n^{2})$ пам’яті, для збереження $32$-бітових чисел.
  \subsection{Хитрощі реалізації}
    Зрозуміло, що усі операції додавання та множення слід виконувати за модулем $10^{5}$, оскільки нам важливі лише останні $5$ цифр числа. Але, слід звернути увагу, на вимогу з умови:
    \begin{quote}
    \say{Это число может быть очень большим, поэтому выведите только его \textbf{последние $5$ цифр}}
    \end{quote}
    Саме тому потрібно додатково зберігати інформацію, чи відбувалося переповнення при обрахунках шуканої величини.
\end{document}